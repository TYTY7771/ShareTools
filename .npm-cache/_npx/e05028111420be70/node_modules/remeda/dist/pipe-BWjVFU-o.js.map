{"version":3,"file":"pipe-BWjVFU-o.js","names":["input: unknown","lazySequence: Array<PreparedLazyOperation>","accumulator: Array<unknown>","item: unknown","lazySequence: ReadonlyArray<PreparedLazyOperation>","lazyResult: LazyResult<any>","op: LazyOp","something: unknown"],"sources":["../src/pipe.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable jsdoc/check-param-names -- we don't document the op params, it'd be redundant */\n\nimport type { LazyDefinition } from \"./internal/types/LazyDefinition\";\nimport type { LazyEvaluator } from \"./internal/types/LazyEvaluator\";\nimport type { LazyResult } from \"./internal/types/LazyResult\";\nimport { SKIP_ITEM } from \"./internal/utilityEvaluators\";\n\ntype PreparedLazyOperation = LazyEvaluator & {\n  readonly isSingle: boolean;\n\n  // These are intentionally mutable, they maintain the lazy piped state.\n  index: number;\n  items: Array<unknown>;\n};\n\ntype LazyOp = LazyDefinition & ((input: unknown) => unknown);\n\n/**\n * Perform left-to-right function composition.\n *\n * @param value - The initial value.\n * @param operations - The list of operations to apply.\n * @signature R.pipe(data, op1, op2, op3)\n * @example\n *    R.pipe(\n *      [1, 2, 3, 4],\n *      R.map(x => x * 2),\n *      arr => [arr[0] + arr[1], arr[2] + arr[3]],\n *    ) // => [6, 14]\n * @dataFirst\n * @category Function\n */\nexport function pipe<A>(value: A): A;\n\nexport function pipe<A, B>(value: A, op1: (input: A) => B): B;\n\nexport function pipe<A, B, C>(\n  value: A,\n  op1: (input: A) => B,\n  op2: (input: B) => C,\n): C;\n\nexport function pipe<A, B, C, D>(\n  value: A,\n  op1: (input: A) => B,\n  op2: (input: B) => C,\n  op3: (input: C) => D,\n): D;\n\nexport function pipe<A, B, C, D, E>(\n  value: A,\n  op1: (input: A) => B,\n  op2: (input: B) => C,\n  op3: (input: C) => D,\n  op4: (input: D) => E,\n): E;\n\nexport function pipe<A, B, C, D, E, F>(\n  value: A,\n  op1: (input: A) => B,\n  op2: (input: B) => C,\n  op3: (input: C) => D,\n  op4: (input: D) => E,\n  op5: (input: E) => F,\n): F;\n\nexport function pipe<A, B, C, D, E, F, G>(\n  value: A,\n  op1: (input: A) => B,\n  op2: (input: B) => C,\n  op3: (input: C) => D,\n  op4: (input: D) => E,\n  op5: (input: E) => F,\n  op6: (input: F) => G,\n): G;\n\nexport function pipe<A, B, C, D, E, F, G, H>(\n  value: A,\n  op1: (input: A) => B,\n  op2: (input: B) => C,\n  op3: (input: C) => D,\n  op4: (input: D) => E,\n  op5: (input: E) => F,\n  op6: (input: F) => G,\n  op7: (input: G) => H,\n): H;\n\nexport function pipe<A, B, C, D, E, F, G, H, I>(\n  value: A,\n  op1: (input: A) => B,\n  op2: (input: B) => C,\n  op3: (input: C) => D,\n  op4: (input: D) => E,\n  op5: (input: E) => F,\n  op6: (input: F) => G,\n  op7: (input: G) => H,\n  op8: (input: H) => I,\n): I;\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J>(\n  value: A,\n  op1: (input: A) => B,\n  op2: (input: B) => C,\n  op3: (input: C) => D,\n  op4: (input: D) => E,\n  op5: (input: E) => F,\n  op6: (input: F) => G,\n  op7: (input: G) => H,\n  op8: (input: H) => I,\n  op9: (input: I) => J,\n): J;\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K>(\n  value: A,\n  op01: (input: A) => B,\n  op02: (input: B) => C,\n  op03: (input: C) => D,\n  op04: (input: D) => E,\n  op05: (input: E) => F,\n  op06: (input: F) => G,\n  op07: (input: G) => H,\n  op08: (input: H) => I,\n  op09: (input: I) => J,\n  op10: (input: J) => K,\n): K;\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(\n  value: A,\n  op01: (input: A) => B,\n  op02: (input: B) => C,\n  op03: (input: C) => D,\n  op04: (input: D) => E,\n  op05: (input: E) => F,\n  op06: (input: F) => G,\n  op07: (input: G) => H,\n  op08: (input: H) => I,\n  op09: (input: I) => J,\n  op10: (input: J) => K,\n  op11: (input: K) => L,\n): L;\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  value: A,\n  op01: (input: A) => B,\n  op02: (input: B) => C,\n  op03: (input: C) => D,\n  op04: (input: D) => E,\n  op05: (input: E) => F,\n  op06: (input: F) => G,\n  op07: (input: G) => H,\n  op08: (input: H) => I,\n  op09: (input: I) => J,\n  op10: (input: J) => K,\n  op11: (input: K) => L,\n  op12: (input: L) => M,\n): M;\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  value: A,\n  op01: (input: A) => B,\n  op02: (input: B) => C,\n  op03: (input: C) => D,\n  op04: (input: D) => E,\n  op05: (input: E) => F,\n  op06: (input: F) => G,\n  op07: (input: G) => H,\n  op08: (input: H) => I,\n  op09: (input: I) => J,\n  op10: (input: J) => K,\n  op11: (input: K) => L,\n  op12: (input: L) => M,\n  op13: (input: M) => N,\n): N;\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  value: A,\n  op01: (input: A) => B,\n  op02: (input: B) => C,\n  op03: (input: C) => D,\n  op04: (input: D) => E,\n  op05: (input: E) => F,\n  op06: (input: F) => G,\n  op07: (input: G) => H,\n  op08: (input: H) => I,\n  op09: (input: I) => J,\n  op10: (input: J) => K,\n  op11: (input: K) => L,\n  op12: (input: L) => M,\n  op13: (input: M) => N,\n  op14: (input: N) => O,\n): O;\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  value: A,\n  op01: (input: A) => B,\n  op02: (input: B) => C,\n  op03: (input: C) => D,\n  op04: (input: D) => E,\n  op05: (input: E) => F,\n  op06: (input: F) => G,\n  op07: (input: G) => H,\n  op08: (input: H) => I,\n  op09: (input: I) => J,\n  op10: (input: J) => K,\n  op11: (input: K) => L,\n  op12: (input: L) => M,\n  op13: (input: M) => N,\n  op14: (input: N) => O,\n  op15: (input: O) => P,\n): P;\n\nexport function pipe(\n  input: unknown,\n  ...operations: ReadonlyArray<LazyOp | ((value: any) => unknown)>\n): any {\n  let output = input;\n\n  const lazyOperations = operations.map((op) =>\n    \"lazy\" in op ? prepareLazyOperation(op) : undefined,\n  );\n\n  let operationIndex = 0;\n  while (operationIndex < operations.length) {\n    const lazyOperation = lazyOperations[operationIndex];\n    if (lazyOperation === undefined || !isIterable(output)) {\n      const operation = operations[operationIndex]!;\n      output = operation(output);\n      operationIndex += 1;\n      continue;\n    }\n\n    const lazySequence: Array<PreparedLazyOperation> = [];\n    for (let index = operationIndex; index < operations.length; index++) {\n      const lazyOp = lazyOperations[index];\n      if (lazyOp === undefined) {\n        break;\n      }\n\n      lazySequence.push(lazyOp);\n      if (lazyOp.isSingle) {\n        break;\n      }\n    }\n\n    const accumulator: Array<unknown> = [];\n\n    for (const value of output) {\n      const shouldExitEarly = processItem(value, accumulator, lazySequence);\n      if (shouldExitEarly) {\n        break;\n      }\n    }\n\n    const { isSingle } = lazySequence.at(-1)!;\n    output = isSingle ? accumulator[0] : accumulator;\n    operationIndex += lazySequence.length;\n  }\n  return output;\n}\n\nfunction processItem(\n  item: unknown,\n  // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types -- Intentionally mutable, we use the accumulator directly to accumulate the results.\n  accumulator: Array<unknown>,\n  // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types -- Intentionally mutable, the lazy sequence is stateful and contains the state needed to compute the next value lazily.\n  lazySequence: ReadonlyArray<PreparedLazyOperation>,\n): boolean {\n  if (lazySequence.length === 0) {\n    accumulator.push(item);\n    return false;\n  }\n\n  let currentItem = item;\n\n  let lazyResult: LazyResult<any> = SKIP_ITEM;\n  let isDone = false;\n  for (const [operationsIndex, lazyFn] of lazySequence.entries()) {\n    const { index, items } = lazyFn;\n    items.push(currentItem);\n    lazyResult = lazyFn(currentItem, index, items);\n    lazyFn.index += 1;\n    if (lazyResult.hasNext) {\n      if (lazyResult.hasMany ?? false) {\n        for (const subItem of lazyResult.next as ReadonlyArray<unknown>) {\n          const subResult = processItem(\n            subItem,\n            accumulator,\n            lazySequence.slice(operationsIndex + 1),\n          );\n          if (subResult) {\n            return true;\n          }\n        }\n        return isDone;\n      }\n      currentItem = lazyResult.next;\n    }\n    if (!lazyResult.hasNext) {\n      break;\n    }\n    // process remaining functions in the pipe\n    // but don't process remaining elements in the input array\n    if (lazyResult.done) {\n      isDone = true;\n    }\n  }\n  if (lazyResult.hasNext) {\n    accumulator.push(currentItem);\n  }\n  return isDone;\n}\n\nfunction prepareLazyOperation(op: LazyOp): PreparedLazyOperation {\n  const { lazy, lazyArgs } = op;\n  const fn = lazy(...lazyArgs);\n  return Object.assign(fn, {\n    isSingle: lazy.single ?? false,\n    index: 0,\n    items: [] as Array<unknown>,\n  });\n}\n\nfunction isIterable(something: unknown): something is Iterable<unknown> {\n  // Check for null and undefined to avoid errors when accessing Symbol.iterator\n  return (\n    typeof something === \"string\" ||\n    (typeof something === \"object\" &&\n      something !== null &&\n      Symbol.iterator in something)\n  );\n}\n"],"mappings":"4DAoNA,SAAgB,EACdA,EACA,GAAG,EACE,CACL,IAAI,EAAS,EAEP,EAAiB,EAAW,IAAI,AAAC,GACrC,SAAU,EAAK,EAAqB,EAAG,CAAG,IAAA,GAC3C,CAEG,EAAiB,EACrB,KAAO,EAAiB,EAAW,QAAQ,CACzC,IAAM,EAAgB,EAAe,GACrC,GAAI,IAAkB,IAAA,IAAa,CAAC,EAAW,EAAO,CAAE,CACtD,IAAM,EAAY,EAAW,GAC7B,EAAS,EAAU,EAAO,CAC1B,GAAkB,EAClB,QACD,CAED,IAAMC,EAA6C,CAAE,EACrD,IAAK,IAAI,EAAQ,EAAgB,EAAQ,EAAW,OAAQ,IAAS,CACnE,IAAM,EAAS,EAAe,GAM9B,GALI,IAAW,IAAA,KAIf,EAAa,KAAK,EAAO,CACrB,EAAO,UACT,KAEH,CAED,IAAMC,EAA8B,CAAE,EAEtC,IAAK,IAAM,KAAS,EAAQ,CAC1B,IAAM,EAAkB,EAAY,EAAO,EAAa,EAAa,CACrE,GAAI,EACF,KAEH,CAED,GAAM,CAAE,WAAU,CAAG,EAAa,GAAG,GAAG,CACxC,EAAS,EAAW,EAAY,GAAK,EACrC,GAAkB,EAAa,MAChC,CACD,OAAO,CACR,CAED,SAAS,EACPC,EAEAD,EAEAE,EACS,CACT,GAAI,EAAa,SAAW,EAE1B,OADA,EAAY,KAAK,EAAK,CACf,GAGT,IAAI,EAAc,EAEdC,EAA8B,EAC9B,EAAS,GACb,IAAK,GAAM,CAAC,EAAiB,EAAO,GAAI,EAAa,SAAS,CAAE,CAC9D,GAAM,CAAE,QAAO,QAAO,CAAG,EAIzB,GAHA,EAAM,KAAK,EAAY,CACvB,EAAa,EAAO,EAAa,EAAO,EAAM,CAC9C,EAAO,OAAS,EACZ,EAAW,QAAS,CACtB,GAAI,EAAW,SAAW,GAAO,CAC/B,IAAK,IAAM,KAAW,EAAW,KAAgC,CAC/D,IAAM,EAAY,EAChB,EACA,EACA,EAAa,MAAM,EAAkB,EAAE,CACxC,CACD,GAAI,EACF,MAAO,EAEV,CACD,OAAO,CACR,CACD,EAAc,EAAW,IAC1B,CACD,GAAI,CAAC,EAAW,QACd,MAIE,EAAW,OACb,EAAS,GAEZ,CAID,OAHI,EAAW,SACb,EAAY,KAAK,EAAY,CAExB,CACR,CAED,SAAS,EAAqBC,EAAmC,CAC/D,GAAM,CAAE,OAAM,WAAU,CAAG,EACrB,EAAK,EAAK,GAAG,EAAS,CAC5B,OAAO,OAAO,OAAO,EAAI,CACvB,SAAU,EAAK,QAAU,GACzB,MAAO,EACP,MAAO,CAAE,CACV,EAAC,AACH,CAED,SAAS,EAAWC,EAAoD,CAEtE,OACE,OAAO,GAAc,UACpB,OAAO,GAAc,YACpB,GACA,OAAO,YAAY,CAExB"}