{"version":3,"file":"conditional-BjDWMG87.js","names":["isArg: (firstArg: unknown) => firstArg is T","implementation: (\n    data: unknown,\n    firstArg: T,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Function inference in typescript relies on `any` to work, it doesn't work with `unknown`\n    ...args: any\n  ) => unknown","args: ReadonlyArray<unknown>","data: unknown","conditionalPlus: WithUtils<typeof conditional>","data: In","maybeCase: unknown","then: (data: unknown) => unknown"],"sources":["../src/internal/purryOn.ts","../src/conditional.ts"],"sourcesContent":["/**\n * Utility for purrying functions based on a predicate for the first argument.\n *\n * This is useful for purrying functions with a variadic argument list.\n */\nexport function purryOn<T>(\n  isArg: (firstArg: unknown) => firstArg is T,\n  implementation: (\n    data: unknown,\n    firstArg: T,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Function inference in typescript relies on `any` to work, it doesn't work with `unknown`\n    ...args: any\n  ) => unknown,\n  args: ReadonlyArray<unknown>,\n): unknown {\n  return isArg(args[0])\n    ? // @ts-expect-error [ts2556] - This is a low-level function that assumes the function declaration and setup is correct and won't result in typing issues when called dynamically.\n      (data: unknown) => implementation(data, ...args)\n    : // @ts-expect-error [ts2556] - This is a low-level function that assumes the function declaration and setup is correct and won't result in typing issues when called dynamically.\n      implementation(...args);\n}\n","/* eslint-disable @typescript-eslint/no-deprecated -- (See TODO below.) */\n\nimport { purryOn } from \"./internal/purryOn\";\nimport type { GuardType } from \"./internal/types/GuardType\";\n\ntype Case<\n  In,\n  Out,\n  When extends (x: In) => boolean = (x: In) => boolean,\n> = readonly [when: When, then: (x: GuardType<When, In> & In) => Out];\n\ntype DefaultCase<In, Out> = (x: In) => Out;\n\n// For easier discovery and to allow us to have a single exported function we\n// merge a set of utilities with the function itself. This provides a namespace-\n// like structure where the function could be used directly by calling it, but\n// also as the container of additional utilities.\ntype Utilities = {\n  readonly defaultCase: typeof defaultCase;\n};\ntype WithUtils<T> = T & Utilities;\n\nconst conditionalPlus: WithUtils<typeof conditional> = Object.assign(\n  conditional,\n  { defaultCase } satisfies Utilities,\n);\nexport { conditionalPlus as conditional };\n\n/**\n * Executes a transformer function based on the first matching predicate,\n * functioning like a series of `if...else if...` statements. It sequentially\n * evaluates each case and, upon finding a truthy predicate, runs the\n * corresponding transformer, and returns, ignoring any further cases, even if\n * they would match.\n *\n * *NOTE*: Some type-predicates may fail to narrow the param type of their\n * transformer; in such cases wrap your type-predicate in an anonymous arrow\n * function: e.g., instead of\n * `conditional(..., [myTypePredicate, myTransformer], ...)`, use\n * `conditional(..., [($) => myTypePredicate($), myTransformer], ...)`.\n *\n * To add a a default, catch-all, case you can provide a single callback\n * function (instead of a 2-tuple) as the last case. This is equivalent to\n * adding a case with a trivial always-true predicate as it's condition (see\n * example).\n *\n * For simpler cases you should also consider using `when` instead.\n *\n * Due to TypeScript's inability to infer the result of negating a type-\n * predicate we can't refine the types used in subsequent cases based on\n * previous conditions. Using a `switch (true)` statement or ternary operators\n * is recommended for more precise type control when such type narrowing is\n * needed.\n *\n * !IMPORTANT! - Unlike similar implementations in Lodash and Ramda, the Remeda\n * implementation **doesn't** implicitly return `undefined` as a fallback when\n * when none of the cases match; and instead **throws** an exception in those\n * cases! You have to explicitly provide a default case, and can use\n * `constant(undefined)` as your last case to replicate that behavior.\n *\n * @param cases - A list of (up to 10) cases. Each case can be either:\n * - A 2-tuple consisting of a predicate (or type-predicate) and a transformer\n *   function that processes the data if the predicate matches.\n * - A single callback function that acts as a default fallback case.\n * @returns The output of the matched transformer. If no cases match, an\n * exception is thrown. The return type is a union of the return types of all\n * provided transformers.\n * @signature\n *   R.conditional(...cases)(data);\n * @example\n *   const nameOrId = 3 as string | number | boolean;\n *\n *   R.pipe(\n *     nameOrId,\n *     R.conditional(\n *       [R.isString, (name) => `Hello ${name}`],\n *       [R.isNumber, (id) => `Hello ID: ${id}`],\n *     ),\n *   ); //=> 'Hello ID: 3' (typed as `string`), can throw!.\n *\n *   R.pipe(\n *     nameOrId,\n *     R.conditional(\n *       [R.isString, (name) => `Hello ${name}`],\n *       [R.isNumber, (id) => `Hello ID: ${id}`],\n *       R.constant(undefined),\n *     ),\n *   ); //=> 'Hello ID: 3' (typed as `string | undefined`), won't throw.\n *\n *   R.pipe(\n *     nameOrId,\n *     R.conditional(\n *       [R.isString, (name) => `Hello ${name}`],\n *       [R.isNumber, (id) => `Hello ID: ${id}`],\n *       (something) => `Hello something (${JSON.stringify(something)})`,\n *     ),\n *   ); //=> 'Hello ID: 3' (typed as `string`), won't throw.\n * @dataLast\n * @category Function\n */\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Return0,\n  Fallback = never,\n>(\n  // TODO [>2]: TypeScript has problems inferring narrowed types within the case tuples, making it hard to work with this utility. Removing the tuple wrappers solves these issues without impacting the API too much. @see https://github.com/remeda/remeda/issues/847#issuecomment-3057371891\n  case0: Case<T, Return0, Fn0>,\n  fallback?: DefaultCase<T, Fallback>,\n): (data: T) => Return0 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  // TODO [>2]: Exclude previous guarded types from the next functions in the chain. Although this isn't a prefect solution, it's the common approach to compute the \"negation\" of a type-predicate, and would provide a more comfortable API for bigger chains for cases like discriminated unions. This TODO is at the first occurrence where it is relevant, but it should be applied to **all** subsequent overloads. p.s. don't forget to update the docs too!\n  Fn1 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  fallback?: DefaultCase<T, Fallback>,\n): (data: T) => Return0 | Return1 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  fallback?: DefaultCase<T, Fallback>,\n): (data: T) => Return0 | Return1 | Return2 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  fallback?: DefaultCase<T, Fallback>,\n): (data: T) => Return0 | Return1 | Return2 | Return3 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  fallback?: DefaultCase<T, Fallback>,\n): (data: T) => Return0 | Return1 | Return2 | Return3 | Return4 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  fallback?: DefaultCase<T, Fallback>,\n): (\n  data: T,\n) => Return0 | Return1 | Return2 | Return3 | Return4 | Return5 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  fallback?: DefaultCase<T, Fallback>,\n): (\n  data: T,\n) =>\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  fallback?: DefaultCase<T, Fallback>,\n): (\n  data: T,\n) =>\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Fn8 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Return8,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  case8: Case<T, Return8, Fn8>,\n  fallback?: DefaultCase<T, Fallback>,\n): (\n  data: T,\n) =>\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Return8\n  | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Fn8 extends (x: T) => boolean,\n  Fn9 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Return8,\n  Return9,\n  Fallback = never,\n>(\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  case8: Case<T, Return8, Fn8>,\n  case9: Case<T, Return9, Fn9>,\n  fallback?: DefaultCase<T, Fallback>,\n): (\n  data: T,\n) =>\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Return8\n  | Return9\n  | Fallback;\n\n/**\n * Executes a transformer function based on the first matching predicate,\n * functioning like a series of `if...else if...` statements. It sequentially\n * evaluates each case and, upon finding a truthy predicate, runs the\n * corresponding transformer, and returns, ignoring any further cases, even if\n * they would match.\n *\n * *NOTE*: Some type-predicates may fail to narrow the param type of their\n * transformer; in such cases wrap your type-predicate in an anonymous arrow\n * function: e.g., instead of\n * `conditional(..., [myTypePredicate, myTransformer], ...)`, use\n * `conditional(..., [($) => myTypePredicate($), myTransformer], ...)`.\n *\n * To add a a default, catch-all, case you can provide a single callback\n * function (instead of a 2-tuple) as the last case. This is equivalent to\n * adding a case with a trivial always-true predicate as it's condition (see\n * example).\n *\n * For simpler cases you should also consider using `when` instead.\n *\n * Due to TypeScript's inability to infer the result of negating a type-\n * predicate we can't refine the types used in subsequent cases based on\n * previous conditions. Using a `switch (true)` statement or ternary operators\n * is recommended for more precise type control when such type narrowing is\n * needed.\n *\n * !IMPORTANT! - Unlike similar implementations in Lodash and Ramda, the Remeda\n * implementation **doesn't** implicitly return `undefined` as a fallback when\n * when none of the cases match; and instead **throws** an exception in those\n * cases! You have to explicitly provide a default case, and can use\n * `constant(undefined)` as your last case to replicate that behavior.\n *\n * @param data - The input data to be evaluated against the provided cases.\n * @param cases - A list of (up to 10) cases. Each case can be either:\n * - A 2-tuple consisting of a predicate (or type-predicate) and a transformer\n *   function that processes the data if the predicate matches.\n * - A single callback function that acts as a default fallback case.\n * @returns The output of the matched transformer. If no cases match, an\n * exception is thrown. The return type is a union of the return types of all\n * provided transformers.\n * @signature\n *   R.conditional(data, ...cases);\n * @example\n *   const nameOrId = 3 as string | number | boolean;\n *\n *   R.conditional(\n *     nameOrId,\n *     [R.isString, (name) => `Hello ${name}`],\n *     [R.isNumber, (id) => `Hello ID: ${id}`],\n *   ); //=> 'Hello ID: 3' (typed as `string`), can throw!.\n *\n *   R.conditional(\n *     nameOrId,\n *     [R.isString, (name) => `Hello ${name}`],\n *     [R.isNumber, (id) => `Hello ID: ${id}`],\n *     R.constant(undefined),\n *   ); //=> 'Hello ID: 3' (typed as `string | undefined`), won't throw.\n *\n *   R.conditional(\n *     nameOrId,\n *     [R.isString, (name) => `Hello ${name}`],\n *     [R.isNumber, (id) => `Hello ID: ${id}`],\n *     (something) => `Hello something (${JSON.stringify(something)})`,\n *   ); //=> 'Hello ID: 3' (typed as `string`), won't throw.\n * @dataFirst\n * @category Function\n */\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Return0,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Return1 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Return1 | Return2 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Return1 | Return2 | Return3 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Return1 | Return2 | Return3 | Return4 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  fallback?: DefaultCase<T, Fallback>,\n): Return0 | Return1 | Return2 | Return3 | Return4 | Return5 | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  fallback?: DefaultCase<T, Fallback>,\n):\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  fallback?: DefaultCase<T, Fallback>,\n):\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Fn8 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Return8,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  case8: Case<T, Return8, Fn8>,\n  fallback?: DefaultCase<T, Fallback>,\n):\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Return8\n  | Fallback;\n\nfunction conditional<\n  T,\n  Fn0 extends (x: T) => boolean,\n  Fn1 extends (x: T) => boolean,\n  Fn2 extends (x: T) => boolean,\n  Fn3 extends (x: T) => boolean,\n  Fn4 extends (x: T) => boolean,\n  Fn5 extends (x: T) => boolean,\n  Fn6 extends (x: T) => boolean,\n  Fn7 extends (x: T) => boolean,\n  Fn8 extends (x: T) => boolean,\n  Fn9 extends (x: T) => boolean,\n  Return0,\n  Return1,\n  Return2,\n  Return3,\n  Return4,\n  Return5,\n  Return6,\n  Return7,\n  Return8,\n  Return9,\n  Fallback = never,\n>(\n  data: T,\n  case0: Case<T, Return0, Fn0>,\n  case1: Case<T, Return1, Fn1>,\n  case2: Case<T, Return2, Fn2>,\n  case3: Case<T, Return3, Fn3>,\n  case4: Case<T, Return4, Fn4>,\n  case5: Case<T, Return5, Fn5>,\n  case6: Case<T, Return6, Fn6>,\n  case7: Case<T, Return7, Fn7>,\n  case8: Case<T, Return8, Fn8>,\n  case9: Case<T, Return9, Fn9>,\n  fallback?: DefaultCase<T, Fallback>,\n):\n  | Return0\n  | Return1\n  | Return2\n  | Return3\n  | Return4\n  | Return5\n  | Return6\n  | Return7\n  | Return8\n  | Return9\n  | Fallback;\n\nfunction conditional(...args: ReadonlyArray<unknown>): unknown {\n  return purryOn(isCase, conditionalImplementation, args);\n}\n\nfunction conditionalImplementation<In, Out>(\n  data: In,\n  ...cases: ReadonlyArray<Case<In, Out> | DefaultCase<In, Out>>\n): Out {\n  for (const current of cases) {\n    if (typeof current === \"function\") {\n      return current(data);\n    }\n\n    const [when, then] = current;\n    if (when(data)) {\n      return then(data);\n    }\n  }\n\n  // TODO [>2]: When we built this function originally we didn't want to have to always return `undefined` and force users to always have to handle that case even when they knew it would never happen. In hindsight that was wrong and we can support this at the type-level without throwing. If users want to throw they can always have an explicit fallback that does that (and we might add a throw utility in v3 too!).\n  throw new Error(\"conditional: data failed for all cases\");\n}\n\nfunction isCase(maybeCase: unknown): maybeCase is Case<unknown, unknown> {\n  if (!Array.isArray(maybeCase)) {\n    return false;\n  }\n\n  const [when, then, ...rest] = maybeCase as ReadonlyArray<unknown>;\n  return (\n    typeof when === \"function\" &&\n    when.length <= 1 &&\n    typeof then === \"function\" &&\n    then.length <= 1 &&\n    rest.length === 0\n  );\n}\n\n// TODO [2025-09-04]: Remove the deprecated `defaultCase` utility.\n/**\n *! **DEPRECATED**: `conditional` now accepts a default, catch-all, callback directly and no longer needs this utility wrapper. Use `constant(undefined)` as your last case instead (see example).\n *\n * @example\n *   const nameOrId = 3 as string | number;\n *   R.conditional(\n *     nameOrId,\n *     [R.isString, (name) => `Hello ${name}`],\n *     [R.isNumber, (id) => `Hello ID: ${id}`],\n *     // Was: `R.conditional.defaultCase(),`, Now:\n *     constant(undefined),\n *   ); //=> 'Hello ID: 3'\n * @deprecated `conditional` now accepts a default, catch-all, callback\n * directly and no longer needs this utility wrapper. Use `constant(undefined)`\n * as your last case instead (see example).\n */\nfunction defaultCase(): Case<unknown, undefined>;\n\n/**\n *! **DEPRECATED**: `conditional` now accepts a default, catch-all, callback directly and no longer needs this utility wrapper. Simply put your `then` callback as the last case (see example).\n *\n * @param then - You only need to provide the transformer, the predicate is\n * implicit. @default () => undefined, which is how Lodash and Ramda handle\n * the final fallback case.\n * @example\n *   const nameOrId = 3 as string | number;\n *   R.conditional(\n *     nameOrId,\n *     [R.isString, (name) => `Hello ${name}`],\n *     [R.isNumber, (id) => `Hello ID: ${id}`],\n *     // Was: `R.conditional.defaultCase(\n *     //  (something) => `Hello something (${JSON.stringify(something)})`,\n *     //),`, Now:\n *     (something) => `Hello something (${JSON.stringify(something)})`\n *   ); //=> 'Hello ID: 3'\n * @deprecated `conditional` now accepts a default, catch-all, callback\n * directly and no longer needs this utility wrapper. Simply put your `then`\n * callback as the last case.\n */\nfunction defaultCase<In, Then extends (param: In) => unknown>(\n  then: Then,\n): Case<In, ReturnType<Then>>;\nfunction defaultCase(\n  then: (data: unknown) => unknown = trivialDefaultCase,\n): Case<unknown, unknown> {\n  return [acceptAnything, then];\n}\n\n// We memoize this so it isn't recreated on every invocation of `defaultCase`.\nconst acceptAnything = () => true as const;\n\n// Lodash and Ramda return `undefined` as the default case.\nconst trivialDefaultCase = (): undefined => undefined;\n"],"mappings":"AAKA,SAAgB,EACdA,EACAC,EAMAC,EACS,CACT,OAAO,EAAM,EAAK,GAAG,CAEjB,AAACC,GAAkB,EAAe,EAAM,GAAG,EAAK,CAEhD,EAAe,GAAG,EAAK,AAC5B,CCED,MAAMC,EAAiD,OAAO,OAC5D,EACA,CAAE,aAAa,EAChB,CAssBD,SAAS,EAAY,GAAG,EAAuC,CAC7D,OAAO,EAAQ,EAAQ,EAA2B,EAAK,AACxD,CAED,SAAS,EACPC,EACA,GAAG,EACE,CACL,IAAK,IAAM,KAAW,EAAO,CAC3B,GAAI,OAAO,GAAY,WACrB,OAAO,EAAQ,EAAK,CAGtB,GAAM,CAAC,EAAM,EAAK,CAAG,EACrB,GAAI,EAAK,EAAK,CACZ,OAAO,EAAK,EAAK,AAEpB,CAGD,MAAU,MAAM,yCAAA,AACjB,CAED,SAAS,EAAOC,EAAyD,CACvE,GAAI,CAAC,MAAM,QAAQ,EAAU,CAC3B,MAAO,GAGT,GAAM,CAAC,EAAM,EAAM,GAAG,EAAK,CAAG,EAC9B,OACE,OAAO,GAAS,YAChB,EAAK,QAAU,GACf,OAAO,GAAS,YAChB,EAAK,QAAU,GACf,EAAK,SAAW,CAEnB,CA6CD,SAAS,EACPC,EAAmC,EACX,CACxB,MAAO,CAAC,EAAgB,CAAK,CAC9B,CAGD,MAAM,EAAiB,IAAM,GAGvB,EAAqB,IAAiB,IAAA"}