{"version":3,"file":"invert-BZScEfjD.js","names":["data: Readonly<Record<PropertyKey, PropertyKey>>","result: Record<PropertyKey, PropertyKey>"],"sources":["../src/invert.ts"],"sourcesContent":["import type { Simplify } from \"type-fest\";\nimport { purry } from \"./purry\";\nimport type { ToString } from \"./internal/types/ToString\";\n\ntype Inverted<T extends object> = Simplify<{\n  -readonly [K in keyof T as K extends number | string\n    ? Required<T>[K] extends PropertyKey\n      ? Required<T>[K]\n      : never\n    : never]: ToString<K>;\n}>;\n\n/**\n * Returns an object whose keys and values are swapped. If the object contains duplicate values,\n * subsequent values will overwrite previous values.\n *\n * @param object - The object.\n * @signature\n *    R.invert(object)\n * @example\n *    R.invert({ a: \"d\", b: \"e\", c: \"f\" }) // => { d: \"a\", e: \"b\", f: \"c\" }\n * @dataFirst\n * @category Object\n */\nexport function invert<T extends object>(object: T): Inverted<T>;\n\n/**\n * Returns an object whose keys and values are swapped. If the object contains duplicate values,\n * subsequent values will overwrite previous values.\n *\n * @signature\n *    R.invert()(object)\n * @example\n *    R.pipe({ a: \"d\", b: \"e\", c: \"f\" }, R.invert()); // => { d: \"a\", e: \"b\", f: \"c\" }\n * @dataLast\n * @category Object\n */\nexport function invert<T extends object>(): (object: T) => Inverted<T>;\n\nexport function invert(...args: ReadonlyArray<unknown>): unknown {\n  return purry(invertImplementation, args);\n}\n\nfunction invertImplementation(\n  data: Readonly<Record<PropertyKey, PropertyKey>>,\n): Record<PropertyKey, PropertyKey> {\n  const result: Record<PropertyKey, PropertyKey> = {};\n\n  for (const [key, value] of Object.entries(data)) {\n    result[value] = key;\n  }\n\n  return result;\n}\n"],"mappings":"4CAuCA,SAAgB,EAAO,GAAG,EAAuC,CAC/D,OAAO,EAAM,EAAsB,EAAK,AACzC,CAED,SAAS,EACPA,EACkC,CAClC,IAAMC,EAA2C,CAAE,EAEnD,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,QAAQ,EAAK,CAC7C,EAAO,GAAS,EAGlB,OAAO,CACR"}